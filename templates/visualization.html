<!DOCTYPE html>

<html lang="en">
    <head>
        <title>visualization</title>
        <meta charset="utf-8">
        <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/2.7.1/Chart.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels"></script>
        <script src="https://codepen.io/anon/pen/aWapBE.js"></script>
        <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>

        <link rel="stylesheet" type="text/css" href="../static/visualization.css" />
        <script type="text/javascript" src="../static/example.js" defer></script>

        <link rel="stylesheet" type="text/css" href="https://cdn.datatables.net/1.10.19/css/jquery.dataTables.css">
        <script type="text/javascript" charset="utf8" src="https://cdn.datatables.net/1.10.19/js/jquery.dataTables.js"></script>
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">

        <!-- add datatables buttons functionality -->
        <script type="text/javascript" src="https://cdn.datatables.net/buttons/1.3.1/js/dataTables.buttons.min.js"></script>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.1.3/jszip.min.js"></script>
        <script type="text/javascript" src="https://cdn.datatables.net/buttons/1.3.1/js/buttons.html5.min.js"></script>
        <link rel="shortcut icon" href="../static/favicon.ico" type="image/x-icon">
        <link rel="icon" href="../static/favicon.ico" type="image/x-icon">

    </head>

<body>
<h1>Carleton RFC</h1>
<nav>
<div id="navBar">
      <a id="home_btn" href="#">Home</a>
      <a class="cur_page" id="entry_session_btn" href="#">Entry Session</a>
      <a id="view_download_btn" href="#">View/Download Data</a>
      <a id="visualization_btn" href="#">Visualization</a>
</div>
</nav>


<!-- /* Real food calculator visualization page using Chart.js
 * Author: James Yang (part of the Real Food Calculator comps group)
 *
 * Visualization types:
 * 1) Quick look at our data using general non-interactive charts
 * i) Total real vs nonreal food purchase by year
 * ii) By category real vs nonreal purchase by year (yet to be implemented)
 * iii) Top 5 categories/items/labels-brands/vendors by real and nonreal
 * 
 * 2) Percentage of real food in each food category (fully interactive):
 * Pie chart showing the percentage purchase of each food category
 * Stacked bar chart where each column stands for prominent types of food in that category, and color coded into real vs not
 * Buttons: add/remove food category to be investigated, and how many items to show, add/remove individual items given year, remove whole canvas
 * Update ranking of items by (total $ /real $ / nonreal $ / nonreal $ - real $), and all items are shown in the datatable
 *
 * 3) Most impact/up for change food item (fully interactive):
 * A line chart showing the percentage of increase of purchase for that particular food type plus the percentage real increase for all items in that year
 * plus a bar showing the amount of money increase in total of real food purchase
 * Ranked by the normalized difference between percentage increase for total real food minus percent increase for that one item.
 * Buttons: how many items to shown, add/remove individual items, add/remove category, remove whole canvas, plus a datatable
 *
 * 4) Time series (fully interactive):
 * A line chart showing the increase in real/non-real/all food purchases for food items of all categories
 * Buttons: how many items to shown, add/remove individual items, add/remove category, remove whole canvas, plus a datatable
 *
 * 5) Items/labels/vendor mutual charts:
 * Show the distribution of items and labels for a specific vendor (vice versa if investigating a specific label/item)
 *
 */ -->

 <h2>Quick Look @ This Year's Data</h2>
 <div style = "display: block, width: 100%">

<h3>In terms of the bigger picture ...</h3>
<div class="row">
  <div class="column" style = "width: 50%; height: 25%;  float: left">
    <canvas id="allTimeChart" style="display: block; height: 75px; width: 75px;"></canvas>
  </div>
  <div class="column" style = "width: 25%; height: 25%;  float: left">
    <canvas id="percentChart1" style="display: block; height: 75px; width: 75px;"></canvas>
    <canvas id="percentChart4" style="display: block; height: 75px; width: 75px;"></canvas>
  </div>
  <div class="column" style = "width: 25%; height: 25%;  float: left">
    <canvas id="percentChart3" style="display: block; height: 75px; width: 75px;"></canvas>
    <canvas id="percentChart5" style="display: block; height: 75px; width: 75px;"></canvas>
  </div>
</div>

</div>

<script>
Chart.defaults.global.defaultFontSize = 20;

// all time total real vs nonreal charts by years
getData = $.get('http://cmc307-06.mathcs.carleton.edu:5001/visualization/total_data')

getData.done(function(results) {
  data = {
    labels: results.labels,
    datasets: [
    {
      data: results.real,
      label: "real",
      borderWidth: 2,
      backgroundColor: Array(results.real.length).fill('rgba(255, 99, 132, 0.2)'),
      borderColor: Array(results.real.length).fill('rgba(255,99,132,1)')
    },
    {
      data: results.nonreal,
      label: "nonreal",
      borderWidth: 2,
      backgroundColor: Array(results.nonreal.length).fill('rgba(255, 159, 64, 0.2)'),
      borderColor: Array(results.nonreal.length).fill('rgba(255, 159, 64, 1)')
    }
    ]
  }

  ctx = document.getElementById("allTimeChart").getContext('2d');
  totalChart = new Chart(ctx, {type: 'bar', data:data,
    options: {
    scales: {
      yAxes: [{
        ticks: {
          min: 0
        },
      }],
      xAxes: [{
        ticks: {
          autoSkip: false
        }
      }]
    },
      title: {
        display: true,
        text: "Total Real vs. Nonreal Food Purchase by 3 most recent years"
          }
  }
    })
});

// pie chart
// load data from Flask; shows all categories by year
getData = $.get('http://cmc307-06.mathcs.carleton.edu:5001/visualization/pie_data')

getData.done(function(results) {
    years = results.labels
    // year 1
    yr = years[0]
    result = results[yr]
    data = {
        datasets: [{
            data: result.data,
            backgroundColor: palette('tol', result.data.length).map(function(hex) {
            return '#' + hex;
          })
        }],

        // These labels appear in the legend and in the tooltips when hovering different arcs
        labels: result.labels,
        options: {
            responsive: true
        }
    };

     ctx1 = document.getElementById("percentChart1").getContext('2d');
    myPieChart1 = new Chart(ctx1, {
        type: 'pie',
        data: data ,
        options: {
          title: {
              display: true,
              position: 'bottom',
              text: yr
          }
      }
    });

    // year 2
    yr = years[1]
    result = results[yr]
    data = {
        datasets: [{
            data: result.data,
            backgroundColor: palette('tol', result.data.length).map(function(hex) {
            return '#' + hex;
          })
        }],

        labels: result.labels,
        options: {
            responsive: true
        }
    };

     ctx6 = document.getElementById("percentChart3").getContext('2d');
    myPieChart2 = new Chart(ctx6, {
        type: 'pie',
        data: data ,
        options: {
          title: {
              display: true,
              position: 'bottom',
              text: yr
          }
      }
    });

    // year 3
    yr = years[2]
    result = results[yr]
    data = {
        datasets: [{
            data: result.data,
            backgroundColor: palette('tol', result.data.length).map(function(hex) {
            return '#' + hex;
          })
        }],

        // These labels appear in the legend and in the tooltips when hovering different arcs
        labels: result.labels,
        options: {
            responsive: true
        }
    };

     ctx7 = document.getElementById("percentChart4").getContext('2d');
    myPieChart3 = new Chart(ctx7, {
        type: 'pie',
        data: data ,
        options: {
          title: {
              display: true,
              position: 'bottom',
              text: yr
          }
      }
    });

    // total (of all 3 years)
    yr = years[3]
    result = results.total
    data = {
        datasets: [{
            data: result.data,
            backgroundColor: palette('tol', result.data.length).map(function(hex) {
            return '#' + hex;
          })
        }],

        // These labels appear in the legend and in the tooltips when hovering different arcs
        labels: result.labels,
        options: {
            responsive: true
        }
    };

     ctx8 = document.getElementById("percentChart5").getContext('2d');
    myPieChart4 = new Chart(ctx8, {
        type: 'pie',
        data: data ,
        options: {
          title: {
              display: true,
              position: 'bottom',
              text: yr
          }
      }
    });
})
</script>

 <div style = "display: block, width: 100%">
  <h3>In terms of a smaller picture ...</h3>
  <h3>... But not quite the year you are looking for? Go to the 
    <button type="button" id = "next" onclick = "nextQuick()">following</button> or <button type="button" id = "back" onclick = "backQuick()">preceeding</button> year!!</h3>
<div class="row">
  <div class="column" style = "width: 25%; height: 25%;  float: left">
    <canvas id="realCatChart" style="display: block; height: 75px; width: 75px;"></canvas>
    <canvas id="realVendChart" style="display: block; height: 75px; width: 75px;"></canvas>
  </div>
  <div class="column" style = "width: 25%; height: 25%;  float: left">
    <canvas id="nonCatChart" style="display: block; height: 75px; width: 75px;"></canvas>
    <canvas id="nonVendChart" style="display: block; height: 75px; width: 75px;"></canvas>
  </div>
  <div class="column" style = "width: 25%; height: 25%;  float: left">
    <canvas id="realItemChart" style="display: block; height: 75px; width: 75px;"></canvas>
    <canvas id="realBrandChart" style="display: block; height: 75px; width: 75px;"></canvas>
  </div>
  <div class="column" style = "width: 25%; height: 25%;  float: left">
    <canvas id="nonItemChart" style="display: block; height: 75px; width: 75px;"></canvas>
    <canvas id="nonBrandChart" style="display: block; height: 75px; width: 75px;"></canvas>
  </div>
</div>

</div>

<script>
Chart.defaults.global.plugins.datalabels.display = false

Chart.DatasetController.extend({
    name: "BarAlt",
    draw: function(){
        this.scale.endPoint = 200;
        Chart.types.Bar.prototype.draw.apply(this, arguments);
    }
});

var divs = ["realCatChart", "nonCatChart", "realItemChart", "nonItemChart",
        "realVendChart", "nonVendChart", "realBrandChart", "nonBrandChart"]
var quickCharts = [];
var ctQ = [];


for (i = 0; i < 4; i++) {
  for (j = 0; j < 2; j++) {
    ctx_quick = document.getElementById(divs[2*i + j]).getContext('2d');
    ctQ.push(ctx_quick);
    quickCharts.push(new Chart(ctx_quick, {type: 'bar', options: {scales: {yAxes: [{ticks: {min: 0}}]}}}));
  }
}

// initialize session variable of all available years and the current selected year
sessionStorage.setItem('quickAllYears', JSON.stringify([]));
sessionStorage.setItem('quickCurr', 'null');

drawQuickChart('null'); // draw quick chart without any year input

function drawQuickChart(yr) {
// draw top 5 items/categories/labels/vendors for most recent year
divs = ["realCatChart", "nonCatChart", "realItemChart", "nonItemChart",
        "realVendChart", "nonVendChart", "realBrandChart", "nonBrandChart"]

groups = ['category', 'description', 'vendor', 'label_brand']
type = ['real', 'nonreal']
background = ["rgba(255, 159, 64, 0.2)", "rgba(54, 162, 235, 0.2)"]
border = ["rgba(255, 159, 64)", "rgba(54, 162, 235)"]

prefix = "Top 5 "
title_parts = ['categories', 'items', 'vendors', 'labels/brands']
// quick charts
getData = $.get('http://cmc307-06.mathcs.carleton.edu:5001/visualization/quick_data/' + yr)
getData.done(function(results) {
  year = results.year
for (i = 0; i < 4; i++) {
  for (j = 0; j < 2; j++) {

    key = groups[i] + ":" + type[j]
    labels = results[key].labels
    cost = results[key].cost


  data = {
      datasets: [{
          label: "Purchase in dollars",
          data: cost,
          borderWidth: 2,
          backgroundColor: background[j],
          borderColor: border[j]
      }],
      // These labels appear in the legend and in the tooltips when hovering different arcs
      labels: labels
  };
  title = prefix + title_parts[i] + " " + year + " in " + type[j] + " food"
  //ctx = document.getElementById(divs[2*i + j]).getContext('2d');
  quickCharts[2*i + j] = new Chart(ctQ[2*i + j], {
      type: 'bar',
      data: data,
      options: {
        title: {
              display: true,
              text: title
          },
          scales: {
          xAxes: [{
            ticks: {
              autoSkip: false,
              fontSize: 14
            }
          }],
          yAxes: [{
                  ticks: {
                    min: 0
                  }
              }]
      }
  }});
  }
}
sessionStorage.setItem('quickCurr', results.year);
sessionStorage.setItem('quickAllYears', JSON.stringify(results['all_years']));
});
};

// clear all data on quick chart so that one can be drawn for the newly selected year
function clearQuickChart() {
  for (i = 0; i < quickCharts.length; i++) {
    quickCharts[i].destroy();
  }
  quickCharts = [];
}

// remove the current data and draw for the following year if its data is available in database
function nextQuick() {
  curr = parseInt(sessionStorage.quickCurr) + 1;
  all_years = JSON.parse(sessionStorage.quickAllYears)

  if (!all_years.includes(curr)) {
    alert(curr + " cannot be selected since it cannot be found in database.")
  }

  else {
    clearQuickChart();
    drawQuickChart(curr);
    sessionStorage.setItem("quickCurr", curr)
  }
}

// remove the current data and draw for the previous year if its data is available in database
function backQuick() {
  curr = parseInt(sessionStorage.quickCurr) - 1;
  all_years = JSON.parse(sessionStorage.quickAllYears)

  if (!all_years.includes(curr)) {
    alert(curr + " cannot be selected since it cannot be found in database.")
  }

  else {
    clearQuickChart();
    drawQuickChart(curr);
    sessionStorage.setItem("quickCurr", curr)
  }
}

</script>


<h1>Real vs non-real percentage</h1>

<div style = "display: block; width: 100%">
First, choose a year:
<select id = "yearPercent" name="Show:" style = "width: 5%" onchange="changeYearPercent()">
  <option disabled selected value> select an option </option>
</select>
</div>

<div class="quantity buttons_added">
  Showing
  <input type="button" value="-" class="minus" onclick = "minusPercent()">
  <div id = "showPercent" style = "display: inline">0</div>
  <input type="button" value="+" class="plus" onclick = "addPercent()">
  out of <div id = "allPercent" style = "display: inline">0</div> of the selected category

</div>


<div style = "display: block">
Ranked by (in decreasing order):
<select id = "rank_percent" name="Show:" style = "width: 12%" onchange="changeRankPercent()">
  <option value="minus" selected>Nonreal $ minus Real $</option>
  <option value="add">Total $ purchase</option>
  <option value="real">Real $ purchase</option>
  <option value="nonreal">Nonreal $ purchase</option>
</select>
</div>

<div>
    <label for="add">Add by item:</label>
    <input id="add_percent" type="text" name="text" list = "items_percent" onkeyup = "searchItemPercent()" autocomplete="off">
    <datalist id="items_percent"></datalist>
    <input id = "submit_percent_items" type="submit" value="submit" onclick = "addItemDataPercent('')">
 AND/OR Select a category: 
<select id = "categoriesPercent">
  <option disabled selected value> select an option </option>
</select>
<input id = "submit_cat_percent" type="submit" value="submit" onclick = "addCatDataPercent('')">
</div>

<div>
  Remove:
<button class="btnic" id = "canvas_percent" onclick = "clearCanvasPercent()"><i class="fa fa-close"></i> Remove all canvas</button>
<button class="btnic" id = "remove_cat_percent" onclick = "remove_cat_percent()"><i class="fa fa-close"></i> Remove selected category</button>
<div style = "display:inline" id = "buttons_percent"></div>
</div>

<div class="row">
  <div class="column" style = "width: 60%; height: 30%;  float: left">
    <canvas id="percentChart" style="display: block; width: 60%; height: 700px"></canvas>
  </div>
  <div class="column" style = "width: 40%; height: 30%; display: inline-block;">
    <table id="percent_table" class="display" style = "display: inline-block;">
    <thead>
      <tr>
        <th>Item</th>
        <th>Real</th>
        <th>Nonreal</th>
        <th>Gap (nonreal - real)</th>
        <th>Total</th>
      </tr>
    </thead>
    <tbody>
    </tbody>
</table>
    </div>
</div>

<script>
Chart.defaults.global.plugins.datalabels.display = false

// get all categories in database
c = $.get("http://cmc307-06.mathcs.carleton.edu:5001/visualization/get_categories/");

c.done(function(results) {
  cats = results.cats;
  for (i = 0; i < cats.length; i++) {
    cat = cats[i]
    $("select#categoriesPercent").append( $("<option>")
    .val(cat)
    .html(cat)
);
  }
});

// get most recent years
yrs = $.get("http://cmc307-06.mathcs.carleton.edu:5001/visualization/recent_years");

yrs.done(function(results) {
  y = results.yrs;
  for (i = 0; i < y.length; i++) {
    Y = y[i]
    if (i == 0) {
          $("select#yearPercent").append( $("<option selected>")
    .val(Y)
    .html(Y)
    )}
    else {
    $("select#yearPercent").append( $("<option>")
    .val(Y)
    .html(Y)
);}
  }
  // add option to choose all 3 years combined
  $("select#yearPercent").append( $("<option>")
    .val('total')
    .html('all 3 years'))
});

sessionStorage.setItem("currentPercentCat", "") // current investigated category
sessionStorage.setItem("percentSearch", JSON.stringify([])); // previous searches
sessionStorage.setItem("percentCurrent", JSON.stringify([])); // all the individual items added
sessionStorage.setItem("percentCatCurr", JSON.stringify([])); // all categories items currently show in plot
sessionStorage.setItem("percentCatNot", JSON.stringify([])); // categories items not shown

sessionStorage.setItem("currPercent", JSON.stringify([])); // current labels stored in chart
sessionStorage.setItem("currReal", JSON.stringify([])); // real $ purchase of all labels
sessionStorage.setItem("currNonreal", JSON.stringify([])); // nonreal $ purchase of all labels
sessionStorage.setItem("currSum", JSON.stringify([])); // total $ purchase of all labels
sessionStorage.setItem("currMinus", JSON.stringify([])); // nonreal - real $ purchase of all labels
sessionStorage.setItem("percentDuplicate", JSON.stringify([])); // store duplicate entries between individual items and category

curr_data_percent = ["currMinus", "currSum", "currReal", "currNonreal"]

// search for items for percent chart
function searchItemPercent() {
  x = document.getElementById("add_percent").value;
  if (x.length > 1) {
  searches = $.get("http://cmc307-06.mathcs.carleton.edu:5001/visualization/get_item/" + x);

  old_searches = JSON.parse(sessionStorage.percentSearch);

    searches.done(function(results) {
    if (!arraysEqual(old_searches, results.search)) {
    sessionStorage.setItem("percentSearch", JSON.stringify(results.search));
      var dataList = $("#items_percent");
        dataList.empty();
        if(results.search.length) {
          for(i=0; i<results.search.length; i++) {
            item = results.search[i];
            var opt = $("<option></option>").attr("value", item).attr("text", item);
            dataList.append(opt);
          }
        }
    }});
}
};

// rank methods in order
var rank_methods = ["minus", "add", "real", "nonreal"]

// initialize my bar chart
var myBarChart;
  ctx2 = document.getElementById("percentChart").getContext('2d');
  myBarChart = new Chart(ctx2, {
    data:{
      datasets: [{
          label: "real",
          data: [],
          borderWidth: 2,
          backgroundColor: [],
          borderColor: []
      },
      {
          label: "non-real",
          data: [],
          borderWidth: 2,
          backgroundColor: [],
          borderColor: []
        }
      ],
      labels: []
  },
      type: 'bar',
      options: {
          scales: {
              xAxes: [{
                  stacked: true,
                  ticks: {
                    autoSkip: false
                  }
              }],
              yAxes: [{
                  stacked: true
              }]},
              title: {
              display: true
          },
          responsive: true,
          maintainAspectRatio: false
      }
  });

// datatable initialization
var table_percent;
$(document).ready(function(){table_percent = $('#percent_table').DataTable({
        dom: 'lBfrtip',
        buttons: ['copyHtml5', 'csvHtml5', 'excelHtml5']
    }); });

// given the attributes of an item and the current sorting, find which index to splice it into the chart
function findInsertIndex(d) {
    curr_data_percent = ["currMinus", "currSum", "currReal", "currNonreal"]
    e = document.getElementById("rank_percent");
    var rank = e.options[e.selectedIndex].value;

    val = d[rank_methods.indexOf(rank) + 1]

    chart_data = JSON.parse(sessionStorage[curr_data_percent[rank_methods.indexOf(rank)]])

    index = chart_data.length;
    console.log(chart_data)
    for (k = 0; k < chart_data.length; k++) {
      if (val > chart_data[k]) {
        index = k;
        break;
      }
    }

    curr = JSON.parse(sessionStorage.currPercent)
    curr.splice(index, 0, d[0])
    console.log(curr)
    sessionStorage.setItem("currPercent", JSON.stringify(curr));

    // insert the newly added item to the same spot across all 4 data arrays of the labels
    for (j = 0; j < 4; j++) {
      arr = JSON.parse(sessionStorage[curr_data_percent[j]])
      arr.splice(index, 0, d[j+1]) // rank_methods.indexOf(rank)
      sessionStorage.setItem(curr_data_percent[j], JSON.stringify(arr));
    }
    return index;
} 

// add single item to the time series chart
function addItemDataPercent(override) {
  current_list = JSON.parse(sessionStorage.percentCurrent)

  if (override != '') {y = override;}
  else {y = document.getElementById("add_percent").value;}
  console.log(current_list)
  // check input is longer than 1 and has not appeared in current list
  if (y.length > 1 && !current_list.includes(y)) {
    e = document.getElementById("yearPercent");
    var year = e.options[e.selectedIndex].value;

    searches = $.get("http://cmc307-06.mathcs.carleton.edu:5001/visualization/bar_item/" + y + "+" + year);

    searches.done(function(results) {
      // elements by index: item, real, nonreal, minus, sum
      data = results.data

      index = findInsertIndex(data)

      myBarChart.data.datasets[0].data.splice(index, 0, data[3])
      myBarChart.data.datasets[0].backgroundColor.push('rgba(255, 99, 132, 0.2)')
      myBarChart.data.datasets[0].borderColor.push('rgba(255, 99, 132, 1)')

      myBarChart.data.datasets[1].data.splice(index, 0, data[4])
      myBarChart.data.datasets[1].backgroundColor.push('rgba(255, 159, 64, 0.2)')
      myBarChart.data.datasets[1].borderColor.push('rgba(255, 159, 64, 1)')

      myBarChart.data.labels.splice(index, 0, data[0])

      myBarChart.update();
      table_percent.row.add([data[0], data[3], data[4], data[1], data[2]]).draw(false)

      // add duplicates to entry
      dup = JSON.parse(sessionStorage.percentDuplicate)
      curr = JSON.parse(sessionStorage.percentCatCurr)
      n = JSON.parse(sessionStorage.percentCatNot)
      total = curr.concat(n)
      if (total.length > 0) {
      total_t = total[0].map((col, i) => total.map(row => row[i]));

      if (total_t[0].includes(y)) {
        dup.push(y)
      }

      sessionStorage.setItem("percentDuplicate", JSON.stringify(dup));
    }

    })
    $('#buttons_percent').append('<button class="btnic" id = "percent_' + y + '" onclick = "remove_item_percent(&quot ' + y + '&quot)"><i class="fa fa-close"></i> ' + y + '</button>');
    sessionStorage.setItem("percentCurrent", JSON.stringify(current_list.concat([y])));

  }
}


// add a category to the percent chart
function addCatDataPercent(override) {
  if (override != '') {cat = override;}
  else {cat = $("select#categoriesPercent").val();}
  if (sessionStorage.currentPercentCat != "" && sessionStorage.currentPercentCat != cat) { 
      remove_cat_percent();
    }
  if (sessionStorage.currentPercentCat != cat) {
  e = document.getElementById("rank_percent");
  var rank = e.options[e.selectedIndex].value;

  e = document.getElementById("yearPercent");
  var year = e.options[e.selectedIndex].value;
  searches = $.get("http://cmc307-06.mathcs.carleton.edu:5001/visualization/bar_data/" + cat + "+" + year + "+" + rank);
  searches.done(function(results) {

  // results already sorted given the rank inputted to api.py
  // choose number of items (at most 3 items shown on the chart from selected category at initialization)
  num_items = Math.min(results.items.length, 3)

  // transpose results for easier data wrangling
  result_list = [results.items, results.minus, results.sum, results.real, results.nonreal]
  results = result_list[0].map((col, i) => result_list.map(row => row[i]));

  results_curr = results.slice(0, num_items)
  results_no = results.slice(num_items, results.length)
  // add data to table
  for (i = 0; i < num_items; i++) {
      data = results_curr[i]
      index = findInsertIndex(data)

      myBarChart.data.datasets[0].data.splice(index, 0, data[3])
      myBarChart.data.datasets[0].backgroundColor.push('rgba(255, 99, 132, 0.2)')
      myBarChart.data.datasets[0].borderColor.push('rgba(255, 99, 132, 1)')

      myBarChart.data.datasets[1].data.splice(index, 0, data[4])
      myBarChart.data.datasets[1].backgroundColor.push('rgba(255, 159, 64, 0.2)')
      myBarChart.data.datasets[1].borderColor.push('rgba(255, 159, 64, 1)')
      console.log(myBarChart.data.labels)
      myBarChart.data.labels.splice(index, 0, data[0])
  }

  myBarChart.update();

  show = parseInt($("#showPercent").html()) + results_curr.length
  all = parseInt($("#allPercent").html()) + results.length
  $("#showPercent").html(show)
  $("#allPercent").html(all)

  // add duplicate items
  dup = JSON.parse(sessionStorage.percentDuplicate)
  console.log(dup)
  curr_ind = JSON.parse(sessionStorage.percentCurrent)

  for (i = 0; i < results.length; i++) {
    if (curr_ind.includes(results[i][0])) {
      dup.push(results[i][0])
    }
      table_percent.row.add([results[i][0], results[i][3], results[i][4], results[i][1],results[i][2]]).draw(false)
    }
    sessionStorage.setItem("percentDuplicate", JSON.stringify(dup));

  sessionStorage.setItem("percentCatCurr", JSON.stringify(results_curr));
  sessionStorage.setItem("percentCatNot", JSON.stringify(results_no));
  sessionStorage.setItem("currentPercentCat", cat);

  })
}
};

// remove single item from the chart and the table
function remove_item_percent(item) {
  curr_data_percent = ["currMinus", "currSum", "currReal", "currNonreal"]
  item = item.substring(1)

  curr = JSON.parse(sessionStorage.currPercent) // all the labels currently shown on the plot
  index = curr.indexOf(item)
  myBarChart.data.datasets[0].data.splice(index, 1)

  myBarChart.data.datasets[1].data.splice(index, 1)

  curr.splice(index, 1)
  myBarChart.data.labels.splice(index, 1)
  myBarChart.update();

  item_id = "[id='percent_" + item + "']"
  $(item_id).remove()

  table_percent.rows( function ( idx, data, node ) {
        return data[0] === item;
    } )
    .remove()
    .draw();

    sessionStorage.setItem("currPercent", JSON.stringify(curr));
    for (j = 0; j < 4; j++) {
      arr = JSON.parse(sessionStorage[curr_data_percent[j]])
      arr.splice(index, 1)
      sessionStorage.setItem(curr_data_percent[j], JSON.stringify(arr));
    }

    // update the list that contains all user-entered individual entries
    current_list = JSON.parse(sessionStorage.percentCurrent)
    index = current_list.indexOf(item)
    current_list.splice(index, 1)
    sessionStorage.setItem("percentCurrent", JSON.stringify(current_list));

  // deal with duplicates
  curr_cat = JSON.parse(sessionStorage.percentCatCurr)
  n = JSON.parse(sessionStorage.percentCatNot)
  total = curr_cat.concat(n)
  console.log(total)
  // only check duplicates in category if there are items in there
  if (total.length > 0) {
  total_t = total[0].map((col, i) => total.map(row => row[i]));
  console.log(total_t)

  dup = JSON.parse(sessionStorage.percentDuplicate)
  console.log(dup)
  // add back the duplicate entry if it exists in category data
  if (dup.includes(item)) {
    index = total_t[0].indexOf(item)
    table_percent.row.add([total[index][0], total[index][3], total[index][4], total[index][1],total[index][2]]).draw(false)
    var del = dup.indexOf(item);
    dup.splice(del, 1);
    sessionStorage.setItem("percentDuplicate", JSON.stringify(dup))
  }
}
}

// remove the category for the percent chart
function remove_cat_percent() {
  curr_data_percent = ["currMinus", "currSum", "currReal", "currNonreal"]
  curr_cat = JSON.parse(sessionStorage.percentCatCurr)
  total = curr_cat.concat(JSON.parse(sessionStorage.percentCatNot))
  curr = JSON.parse(sessionStorage.currPercent)
  for (q = 0; q < curr_cat.length; q++) {
    item = curr_cat[q][0]
    index = curr.indexOf(item)
    myBarChart.data.datasets[0].data.splice(index, 1)

    myBarChart.data.datasets[1].data.splice(index, 1)
    myBarChart.data.labels.splice(index, 1)
    curr.splice(index, 1)

    for (j = 0; j < 4; j++) {
      arr = JSON.parse(sessionStorage[curr_data_percent[j]])
      arr.splice(index, 1)
      sessionStorage.setItem(curr_data_percent[j], JSON.stringify(arr));
    }
  }
  myBarChart.update()

  sessionStorage.setItem("currPercent", JSON.stringify(curr));
  sessionStorage.setItem("currentPercentCat", "")

  dup = JSON.parse(sessionStorage.percentDuplicate)
  for (z = 0; z < total.length; z++) {
    item = total[z][0]
    table_percent.rows( function ( idx, data, node ) {
        return data[0] === item;
    } )
    .remove()
    .draw();

  if (dup.includes(item)) {
    total_t = total[0].map((col, i) => total.map(row => row[i]));
    index = total_t[0].indexOf(item)
    table_percent.row.add([total[index][0], total[index][3], total[index][4], total[index][1],total[index][2]]).draw(false)
    var del = dup.indexOf(item);
    dup.splice(del, 1);
  }
  }
  sessionStorage.setItem("percentDuplicate", JSON.stringify(dup))
  // update html
  $("#showPercent").html(0)
  $("#allPercent").html(0)
  sessionStorage.setItem("percentCatCurr", JSON.stringify([]));
  sessionStorage.setItem("percentCatNot", JSON.stringify([]));

}

// remove one entry for category data from the chart
function minusPercent() {
  curr_data_percent = ["currMinus", "currSum", "currReal", "currNonreal"]
  curr_cat = JSON.parse(sessionStorage.percentCatCurr)
  if (curr_cat.length > 0) { 
  curr_not = JSON.parse(sessionStorage.percentCatNot)

  item = curr_cat[curr_cat.length-1][0]
  curr = JSON.parse(sessionStorage.currPercent)
  index = curr.indexOf(item)

  // update bar chart by removing the lowest ranked 
  myBarChart.data.datasets[0].data.splice(index, 1)
  myBarChart.data.datasets[1].data.splice(index, 1)
  myBarChart.data.labels.splice(index, 1)
  myBarChart.data.datasets[0].backgroundColor.splice(0, 1)
  myBarChart.data.datasets[0].borderColor.splice(0, 1)
  myBarChart.data.datasets[1].backgroundColor.splice(0, 1)
  myBarChart.data.datasets[1].borderColor.splice(0, 1)
  myBarChart.update()

  curr_not.splice(0, 0, curr_cat[curr_cat.length-1]) // add to non-displaying category data
  curr.splice(index, 1) // remove from current labels
  curr_cat.splice(curr_cat.length-1, 1) // remove from current category data

  for (j = 0; j < 4; j++) {
    arr = JSON.parse(sessionStorage[curr_data_percent[j]])
    arr.splice(index, 1)
    sessionStorage.setItem(curr_data_percent[j], JSON.stringify(arr));
  }

  sessionStorage.setItem("percentCatCurr", JSON.stringify(curr_cat));
  sessionStorage.setItem("percentCatNot", JSON.stringify(curr_not));
  sessionStorage.setItem("currPercent", JSON.stringify(curr));

  show = parseInt($("#showPercent").html()) - 1
  $("#showPercent").html(show)
}
}

// add an entry from category data to the chart
function addPercent() {
  curr_not = JSON.parse(sessionStorage.percentCatNot)
  if (curr_not.length > 0) { 

  curr_cat = JSON.parse(sessionStorage.percentCatCurr)
  item = curr_not[0][0]
  index = findInsertIndex(curr_not[0])

  myBarChart.data.datasets[0].data.splice(index, 0, curr_not[0][3])
  myBarChart.data.datasets[1].data.splice(index, 0, curr_not[0][4])
  myBarChart.data.labels.splice(index, 0, curr_not[0][0])
  myBarChart.data.datasets[0].backgroundColor.push('rgba(255, 99, 132, 0.2)')
  myBarChart.data.datasets[0].borderColor.push('rgba(255, 99, 132, 1)')
  myBarChart.data.datasets[1].backgroundColor.push('rgba(255, 159, 64, 0.2)')
  myBarChart.data.datasets[1].borderColor.push('rgba(255, 159, 64, 1)')

  myBarChart.update()

  curr_cat = curr_cat.concat([curr_not[0]])
  curr_not.splice(0, 1)

  sessionStorage.setItem("percentCatCurr", JSON.stringify(curr_cat));
  sessionStorage.setItem("percentCatNot", JSON.stringify(curr_not));

  show = parseInt($("#showPercent").html()) + 1
  $("#showPercent").html(show)
}
}

// clear the whole canvas
function clearCanvasPercent() {
  current = JSON.parse(sessionStorage.percentCurrent)
  for (t = 0; t < current.length; t++) {
    remove_item_percent(" " + current[t])
  }
  remove_cat_percent();
  table_percent.clear();

  sessionStorage.setItem("currentPercentCat", "") // current investigated category
  sessionStorage.setItem("percentSearch", JSON.stringify([])); // previous searches
  sessionStorage.setItem("percentCurrent", JSON.stringify([])); // all the individual items added
  sessionStorage.setItem("percentCatCurr", JSON.stringify([]));
  sessionStorage.setItem("percentCatNot", JSON.stringify([]));

  sessionStorage.setItem("currPercent", JSON.stringify([])); // current labels stored in chart
  sessionStorage.setItem("currReal", JSON.stringify([])); 
  sessionStorage.setItem("currNonreal", JSON.stringify([])); 
  sessionStorage.setItem("currSum", JSON.stringify([])); 
  sessionStorage.setItem("currMinus", JSON.stringify([])); 
  sessionStorage.setItem("percentDuplicate", JSON.stringify([]));
}

// change the year of all shown items to the given year; and change the associate order
function changeYearPercent() {
  // store the important data
  updateYearCat = sessionStorage.currentPercentCat
  updateYearItems = JSON.parse(sessionStorage.percentCurrent)
  console.log(updateYearItems)
  // clear the canvas
  clearCanvasPercent();
  console.log(updateYearItems)
  for (u = 0; u < updateYearItems.length; u++) {
    addItemDataPercent(updateYearItems[u])
  }

  if (updateYearCat != '') {
    addCatDataPercent(updateYearCat);
  }
}

// sort A given the sorted index of B
function sortListbyList(A, B) {
  zip = A.map(function(e, i) {
    return [e, B[i]]
  });
  zip = zip.sort(function(a,b){return b[1] - a[1]})
  result = []
  for (s = 0; s < zip.length; s++) {
    result = result.concat([zip[s][0]])
  }
  return result;
}

// change the ranking method and the associate data/chart
function changeRankPercent() {
  show = parseInt($("#showPercent").html())

  e = document.getElementById("rank_percent");
  var rank = e.options[e.selectedIndex].value;
  rank_index = rank_methods.indexOf(rank)

  // load individual data
  current = JSON.parse(sessionStorage.percentCurrent)
  chart_labels = JSON.parse(sessionStorage.currPercent)
  minus = JSON.parse(sessionStorage["currMinus"])
  sum = JSON.parse(sessionStorage["currSum"])
  real = JSON.parse(sessionStorage["currReal"])
  nonreal = JSON.parse(sessionStorage["currNonreal"])

  current_data = [minus, sum, real, nonreal]
  current_data = current_data[0].map((col, i) => current_data.map(row => row[i]));

  sessionStorage.setItem("currPercent", JSON.stringify([])); // current labels stored in chart
  sessionStorage.setItem("currReal", JSON.stringify([])); 
  sessionStorage.setItem("currNonreal", JSON.stringify([])); 
  sessionStorage.setItem("currSum", JSON.stringify([])); 
  sessionStorage.setItem("currMinus", JSON.stringify([])); 

  // clear and redraw everything
  l = chart_labels.length
  myBarChart.data.datasets[0].data.splice(0,l)
  myBarChart.data.datasets[0].backgroundColor.splice(0,l)
  myBarChart.data.datasets[0].borderColor.splice(0,l)

  myBarChart.data.datasets[1].data.splice(0,l)
  myBarChart.data.datasets[1].backgroundColor.splice(0,l)
  myBarChart.data.datasets[1].borderColor.splice(0,l)

  myBarChart.data.labels.splice(0,l)

  for (b = 0; b < current.length; b++) {
    item = current[b]
    index_b = chart_labels.indexOf(item)
    index_c = findInsertIndex([item, minus[index_b],sum[index_b], real[index_b], nonreal[index_b]])

    myBarChart.data.datasets[0].data.splice(index_c, 0, real[index_b])
    myBarChart.data.datasets[0].backgroundColor.push('rgba(255, 99, 132, 0.2)')
    myBarChart.data.datasets[0].borderColor.push('rgba(255, 99, 132, 1)')

    myBarChart.data.datasets[1].data.splice(index_c, 0, nonreal[index_b])
    myBarChart.data.datasets[1].backgroundColor.push('rgba(255, 159, 64, 0.2)')
    myBarChart.data.datasets[1].borderColor.push('rgba(255, 159, 64, 1)')

    myBarChart.data.labels.splice(index_c, 0, item)
  }

  // re-sort category data
  curr_not = JSON.parse(sessionStorage.percentCatNot)
  curr_cat = JSON.parse(sessionStorage.percentCatCurr)

  total = curr_cat.concat(curr_not)

  // do not do anything if no category data is used
  console.log(total)
  if (total.length > 0) {
  total_t = total[0].map((col, i) => total.map(row => row[i]));
  sorting = total_t[1 + rank_index]
  console.log(sorting)

  total = sortListbyList(total, sorting)

  curr_cat = total.slice(0, show)
  curr_not = total.slice(show, total.length)

  // put category data onto the chart inorder
  for (a = 0; a < curr_cat.length; a++) {
    data = curr_cat[a]
    index_a = findInsertIndex(data)

    myBarChart.data.datasets[0].data.splice(index_a, 0, data[3])
    myBarChart.data.datasets[0].backgroundColor.push('rgba(255, 99, 132, 0.2)')
    myBarChart.data.datasets[0].borderColor.push('rgba(255, 99, 132, 1)')

    myBarChart.data.datasets[1].data.splice(index_a, 0, data[4])
    myBarChart.data.datasets[1].backgroundColor.push('rgba(255, 159, 64, 0.2)')
    myBarChart.data.datasets[1].borderColor.push('rgba(255, 159, 64, 1)')

    myBarChart.data.labels.splice(index_a, 0, data[0])

  }
}

  myBarChart.update()

  sessionStorage.setItem("percentCatCurr", JSON.stringify(curr_cat));
  sessionStorage.setItem("percentCatNot", JSON.stringify(curr_not));
}

</script>


<div style = "float: left; width: 100%">
<h1>Hypothetical Increase</h1>

<div>
First, choose a year:
<select id = "yearMixed" name="Show:" style = "width: 5%" onchange="changeYearMixed()">
  <option disabled selected value> select an option </option>
</select>
</div>

<div class="quantity buttons_added">
  Showing
  <input type="button" value="-" class="minus" onclick = "minusMixed()">
  <div id = "showMixed" style = "display: inline">0</div>
  <input type="button" value="+" class="plus" onclick = "addMixed()">
  out of <div id = "allMixed" style = "display: inline">0</div> of the selected category

</div>


<div>
    <label for="add">Add by item:</label>
    <input id="add_mixed" type="text" name="text" list = "items_mixed" onkeyup = "searchItemMixed()" autocomplete="off">
    <datalist id="items_mixed"></datalist>
    <input id = "submit_mixed_item" type="submit" value="submit" onclick = "addItemDataMixed('')">
AND/OR Select a category: 
<select id = "categoriesMixed">
  <option disabled selected value> select an option </option>
</select>
<input id = "submit_cat_mixed" type="submit" value="submit" onclick = "addCatDataMixed('')">
</div>

<div>
  Remove:
<button class="btnic" id = "canvas_mixed" onclick = "clearCanvasMixed()"><i class="fa fa-close"></i> Remove all canvas</button>
<button class="btnic" id = "remove_cat_mixed" onclick = "remove_cat_mixed()"><i class="fa fa-close"></i> Remove selected category</button>
<div style = "display:inline" id = "buttons_mixed"></div>
</div>

<div class="row">
  <div class="column" style = "width: 60%; height: 30%;  float: left">
    <canvas id="mixedChart" style="display: block; width: 60%; height: 700px"></canvas>
  </div>
  <div class="column" style = "width: 40%; height: 30%; display: inline-block;">
    <table id="mixed_table" class="display" style = "display: inline-block;">
    <thead>
      <tr>
        <th>Item</th>
        <th>Dollar amount</th>
        <th>% Increase for item</th>
        <th>% Increase for all</th>
      </tr>
    </thead>
    <tbody>
    </tbody>
</table>
    </div>
</div>

</div>

<script>
// our own round function
function round(value, decimals) {
  return Number(Math.round(value+'e'+decimals)+'e-'+decimals);
}

Chart.defaults.global.plugins.datalabels.display = false

c = $.get("http://cmc307-06.mathcs.carleton.edu:5001/visualization/get_categories/");

c.done(function(results) {
  cats = results.cats;
  for (i = 0; i < cats.length; i++) {
    cat = cats[i]
    $("select#categoriesMixed").append( $("<option>")
    .val(cat)
    .html(cat)
);
  }
});

yrs = $.get("http://cmc307-06.mathcs.carleton.edu:5001/visualization/recent_years");

yrs.done(function(results) {
  y = results.yrs;
  for (i = 0; i < y.length; i++) {
    Y = y[i]
    if (i == 0) {
          $("select#yearMixed").append( $("<option selected>")
    .val(Y)
    .html(Y)
    )}
    else {
    $("select#yearMixed").append( $("<option>")
    .val(Y)
    .html(Y)
);}
  }
  // add for all years
  $("select#yearMixed").append( $("<option>")
    .val('total')
    .html('all 3 years'))
});

sessionStorage.setItem("currentMixedCat", "") // current investigated category
sessionStorage.setItem("mixedSearch", JSON.stringify([])); // previous searches
sessionStorage.setItem("mixedCurrent", JSON.stringify([])); // all the individual items added
sessionStorage.setItem("mixedCatCurr", JSON.stringify([]));
sessionStorage.setItem("mixedCatNot", JSON.stringify([]));

sessionStorage.setItem("currMixed", JSON.stringify([])); // current labels stored in chart
sessionStorage.setItem("currData", JSON.stringify([])); // current data associated with the chart
sessionStorage.setItem("mixedDuplicate", JSON.stringify([])); // store duplicate entries between individual items and category


function searchItemMixed() {
  x = document.getElementById("add_mixed").value;
  if (x.length > 1) {
  searches = $.get("http://cmc307-06.mathcs.carleton.edu:5001/visualization/get_item/" + x);

  old_searches = JSON.parse(sessionStorage.mixedSearch);

    searches.done(function(results) {
    if (!arraysEqual(old_searches, results.search)) {
    sessionStorage.setItem("mixedSearch", JSON.stringify(results.search));
      var dataList = $("#items_mixed");
        dataList.empty();
        if(results.search.length) {
          for(i=0; i<results.search.length; i++) {
            item = results.search[i];
            var opt = $("<option></option>").attr("value", item).attr("text", item);
            dataList.append(opt);
          }
        }
    }});
}
};

// initialize the mixed chart
var myMixedChart;
ctx20 = document.getElementById("mixedChart").getContext('2d');
 myMixedChart = new Chart(ctx20, {
  type: 'bar',
  data: {
    datasets: [{
          type: "bar",
          label: 'Increase in dollar amount',
          data: [],
          backgroundColor: 'rgba(75, 192, 192, 0.2)',
          borderColor: 'rgba(75, 192, 192, 1)',
          yAxisID: "bar",
          datalabels: {
          // display labels for this specific dataset
          display: true,
          anchor: 'center'
        }}, {
          label: 'Percent increase in single item',
          yAxisID: "A",
          type: 'line',
            backgroundColor: 'rgba(255, 99, 132, 0.2)',
            borderColor: 'rgba(255,99,132,1)',
            fill: false
        }, {
          label: 'Percent increase for all purchases',
          yAxisID: "B",
          type: 'line',
        backgroundColor: 'rgba(75, 00, 1300, 0.2)',
        borderColor: 'rgba(75, 00, 1300,1)',
        fill: false
        }],
    labels: []
  },
  options: {
    title: {
      display: true,
      text: "Hypothetical Increase for total produce"
    },
    scales: {
      yAxes: [{
        id: 'A',
        type: 'linear',
        position: 'left',
        ticks: {
          fontColor: 'rgba(255,99,132,1)',
          max: 100.5,
          min: -0.5,
          stepSize: 10,
          callback: function(value, index, values) {
                         if (value !== 100.5 && value != -0.5) {
                             return values[index]
                         }
                     }
        },
          scaleLabel: {
          display: true,
          labelString: 'Percent increase in single item (%)'
        }
      }, {
        id: 'B',
        type: 'linear',
        position: 'right',
        ticks: {
          fontColor: 'rgba(75, 00, 1300,1)',
          beginAtZero: true
        },
          scaleLabel: {
          display: true,
          labelString: 'Percent increase for all purchases (%)'
        }
      }, {
        id: 'bar',
        type: 'linear',
        display: false,
        ticks: {
          beginAtZero: true
        }
      }],
      xAxes: [{
        ticks: {
          autoSkip: false
        }
      }],
      plugins: {
        datalabels: {
           display: false,
           font: {weight: 'bold'},
           align: 'center',
           anchor: 'center',
           clamp: true
        }

      }
    },
    responsive: true,
    maintainAspectRatio: false
  }
});

var table_mixed;
$(document).ready(function(){table_mixed = $('#mixed_table').DataTable({
        dom: 'lBfrtip',
        buttons: ['copyHtml5', 'csvHtml5', 'excelHtml5']
    }); });

// find range of an array
function calcRange(numbers) {
    arr = numbers.slice(0).sort(function(a, b){return b - a});
    return arr[0] - arr[arr.length - 1];
}

function sortListbyList(A, B) {
  zip = A.map(function(e, i) {
    return [e, B[i]]
  });
  zip = zip.sort(function(a,b){return b[1] - a[1]})
  result = []
  for (s = 0; s < zip.length; s++) {
    result = result.concat([zip[s][0]])
  }
  return result;
}

// given the attributes of an item and the current sorting, find which index to splice it into the chart
function findInsertIndexMixed(d) {
  // all, ind, dollar

    chart_data = JSON.parse(sessionStorage.currData)
    chart_labels = JSON.parse(sessionStorage.currMixed)
    console.log(chart_data)
    console.log(chart_labels)
    // if no data in there, then add to be the first one
    if (chart_data.length == 0) {
      index = 0;
      chart_labels.push(d[0])
      chart_data = chart_data.concat([d.slice(1, 4)])
    } 

    else {
    // create copy of the data
    chart_data_new = chart_data.concat([d.slice(1, 4)])
    // chart data order: all, ind, dollars
    curr_rank = []
    chart_data_t = chart_data_new[0].map((col, i) => chart_data_new.map(row => row[i]));
    all_min = Math.min.apply(null, chart_data_t[0]) // all
    ind_min = Math.min.apply(null, chart_data_t[1]) // ind

    // calculation for new ranking order with addition of new item
    all_range = calcRange(chart_data_t[0])
    if (all_range != 0) {all_range = 1/(all_range + all_min);} // = (1 / max)
    ind_range = calcRange(chart_data_t[1])

    console.log(chart_data_t)
    for (p = 0; p < chart_data_t[1].length; p++) {
      w = chart_data_t[0][p]
      v = chart_data_t[1][p]
      console.log(w)
      console.log(v)
      if (v == 0) {
        // if v is 0, which implies that dollar and % increase in all are both 0,
        // then set the second operand as the maximum possible value;
        // this makes sure that item with 0 possible percentage increase is always ranked last.
        curr_rank = curr_rank.concat([w * all_range - (ind_range + ind_min) / 100])
      }
      else{
      curr_rank = curr_rank.concat([w * all_range - v / 100])
      }
      // store the value of newly added elements
      if (p == chart_data_t[1].length - 1) {
        newvar = curr_rank[chart_data_t[1].length - 1]
      }
    }

    // essentially is sorting itself
    curr_rank = sortListbyList(curr_rank, curr_rank)

    index = curr_rank.indexOf(newvar)
    chart_labels.splice(index, 0, d[0])
    chart_data.splice(index, 0, d.slice(1, 4))

} 
    // add new data into the chart labels/data
    sessionStorage.setItem("currMixed", JSON.stringify(chart_labels));
    sessionStorage.setItem("currData", JSON.stringify(chart_data));
    return index;
} 

// add single item to the increase chart
function addItemDataMixed(override) {
  current_list = JSON.parse(sessionStorage.mixedCurrent) // list of individual entered data

  if (override != '') {y = override;}
  else {y = document.getElementById("add_mixed").value;}

  // check input is longer than 1 and has not appeared in current list
  if (y.length > 1 && !current_list.includes(y)) {
    e = document.getElementById("yearMixed");
    var year = e.options[e.selectedIndex].value;

    searches = $.get("http://cmc307-06.mathcs.carleton.edu:5001/visualization/mixed_item/" + y + "+" + year);

    searches.done(function(results) {
      // item, total, ind, dollars
      data = results.data
      console.log(data)
      index = findInsertIndexMixed(data)

      // mixed chart order: dollar, ind, all
      // database results order: all, ind, dollar
      // table order: item, dollar, ind, all (same as mixed)
      myMixedChart.data.datasets[0].data.splice(index, 0, data[3])
      myMixedChart.data.datasets[1].data.splice(index, 0, round(data[2], 2))
      myMixedChart.data.datasets[2].data.splice(index, 0, round(data[1], 2))
      myMixedChart.data.labels.splice(index, 0, data[0])

      myMixedChart.update();
      table_mixed.row.add([data[0], data[3], round(data[2], 2), round(data[1], 2)]).draw(false)

      // add duplicates to entry
      dup = JSON.parse(sessionStorage.mixedDuplicate)
      curr = JSON.parse(sessionStorage.mixedCatCurr)
      n = JSON.parse(sessionStorage.mixedCatNot)
      total = curr.concat(n)
      if (total.length > 0) {
      total_t = total[0].map((col, i) => total.map(row => row[i]));

      if (total_t[0].includes(y)) {
        dup.push(y)
      }

      sessionStorage.setItem("mixedDuplicate", JSON.stringify(dup));
    }

    })
    $('#buttons_mixed').append('<button class="btnic" id = "mixed_' + y + '" onclick = "remove_item_mixed(&quot ' + y + '&quot)"><i class="fa fa-close"></i> ' + y + '</button>');
    sessionStorage.setItem("mixedCurrent", JSON.stringify(current_list.concat([y])));

  }
}


function addCatDataMixed(override) {
  if (override != '') {cat = override;}
  else {cat = $("select#categoriesMixed").val();}
  if (sessionStorage.currentMixedCat != "" && sessionStorage.currentMixedCat != cat) { 
      remove_cat_mixed();
    }
  console.log(sessionStorage.currentMixedCat)
  console.log(cat)
  if (sessionStorage.currentMixedCat != cat) {

  e = document.getElementById("yearMixed");
  var year = e.options[e.selectedIndex].value;
  searches = $.get("http://cmc307-06.mathcs.carleton.edu:5001/visualization/mixed_data/" + cat + "+" + year);
  searches.done(function(results) {

  // results already sorted given the rank inputted to api.py
  num_items = Math.min(results.items.length, 3)
  // new_results = sortCatData(results, num_items)

  // transpose results for easier data wrangling
  result_list = [results.items, results.total_percent, results.ind_percent, results.dollars]
  results = result_list[0].map((col, i) => result_list.map(row => row[i]));

  results_curr = results.slice(0, num_items)
  results_no = results.slice(num_items, results.length)
  // add data to table
  console.log(results)
  for (h = 0; h < num_items; h++) {
      data = results_curr[h]
      index = findInsertIndexMixed(data)

      myMixedChart.data.datasets[0].data.splice(index, 0, data[3])
      myMixedChart.data.datasets[1].data.splice(index, 0, round(data[2], 2))
      myMixedChart.data.datasets[2].data.splice(index, 0, round(data[1], 2))
      myMixedChart.data.labels.splice(index, 0, data[0])
  }

  myMixedChart.update();

  show = parseInt($("#showMixed").html()) + results_curr.length
  all = parseInt($("#allMixed").html()) + results.length
  $("#showMixed").html(show)
  $("#allMixed").html(all)

  // add duplicate items
  dup = JSON.parse(sessionStorage.mixedDuplicate)
  console.log(dup)
  curr_ind = JSON.parse(sessionStorage.mixedCurrent)

  for (i = 0; i < results.length; i++) {
    if (curr_ind.includes(results[i][0])) {
      dup.push(results[i][0])
    }
      table_mixed.row.add([results[i][0], round(results[i][3], 2), round(results[i][2], 2), round(results[i][1], 2)]).draw(false)
    }
    sessionStorage.setItem("mixedDuplicate", JSON.stringify(dup));

  sessionStorage.setItem("mixedCatCurr", JSON.stringify(results_curr));
  sessionStorage.setItem("mixedCatNot", JSON.stringify(results_no));
  sessionStorage.setItem("currentMixedCat", cat);

  })
}
};

function remove_item_mixed(item) {
  item = item.substring(1)

  curr = JSON.parse(sessionStorage.currMixed) // all the labels currently shown on the plot
  console.log(curr)
  index = curr.indexOf(item)
  console.log(index)
  console.log(item)
  myMixedChart.data.datasets[0].data.splice(index, 1)
  myMixedChart.data.datasets[1].data.splice(index, 1)
  myMixedChart.data.datasets[2].data.splice(index, 1)

  curr.splice(index, 1)
  myMixedChart.data.labels.splice(index, 1)
  myMixedChart.update();

  sessionStorage.setItem("currMixed", JSON.stringify(curr));
  item_id = "[id='mixed_" + item + "']"
  $(item_id).remove()

  table_mixed.rows( function ( idx, data, node ) {
        return data[0] === item;
    } )
    .remove()
    .draw();

  // update chart data
  curr_data = JSON.parse(sessionStorage.currData)
  curr_data.splice(index, 1)
  sessionStorage.setItem("currData", JSON.stringify(curr_data));

  // update the list that contains all user-entered individual entries
  current_list = JSON.parse(sessionStorage.mixedCurrent)
  index = current_list.indexOf(item)
  current_list.splice(index, 1)
  sessionStorage.setItem("mixedCurrent", JSON.stringify(current_list));

  // deal with duplicates
  curr_cat = JSON.parse(sessionStorage.mixedCatCurr)
  n = JSON.parse(sessionStorage.mixedCatNot)
  total = curr_cat.concat(n)
  console.log(total)
  // only check duplicates in category if there are items in there
  if (total.length > 0) {
  total_t = total[0].map((col, i) => total.map(row => row[i]));
  console.log(total_t)

  var dup = JSON.parse(sessionStorage.mixedDuplicate)
  console.log(dup)
  // add back the duplicate entry to the table if it exists in category data
  if (dup.includes(item)) {
    index = total_t[0].indexOf(item)
    table_mixed.row.add([total[index][0], total[index][3], round(total[index][2], 2), round(total[index][1], 2)]).draw(false)
    var del = dup.indexOf(item);
    dup.splice(del, 1);
  }
  sessionStorage.setItem("mixedDuplicate", JSON.stringify(dup))
}
}

// remove the category for the increase chart
function remove_cat_mixed() {
  // load existing data
  curr_cat = JSON.parse(sessionStorage.mixedCatCurr)
  total = curr_cat.concat(JSON.parse(sessionStorage.mixedCatNot))
  curr = JSON.parse(sessionStorage.currMixed) // current chart labels
  curr_data = JSON.parse(sessionStorage.currData)
  console.log(curr)
  for (q = 0; q < curr_cat.length; q++) {
    item = curr_cat[q][0]
    index = curr.indexOf(item)
    myMixedChart.data.datasets[0].data.splice(index, 1)
    myMixedChart.data.datasets[1].data.splice(index, 1)
    myMixedChart.data.datasets[2].data.splice(index, 1)
    myMixedChart.data.labels.splice(index, 1)
    curr.splice(index, 1)
    console.log(curr)
    curr_data.splice(index, 1)
    console.log(myMixedChart.data.labels);
  }
  myMixedChart.update()

  sessionStorage.setItem("currMixed", JSON.stringify(curr));
  sessionStorage.setItem("currData", JSON.stringify(curr_data));
  sessionStorage.setItem("currentMixedCat", "")


  var dup = JSON.parse(sessionStorage.mixedDuplicate)
  console.log(dup)
  for (z = 0; z < total.length; z++) {
    item = total[z][0]
    table_mixed.rows( function ( idx, data, node ) {
        return data[0] === item;
    } )
    .remove()
    .draw();

  if (dup.includes(item)) {
    total_t = total[0].map((col, i) => total.map(row => row[i]));
    index = total_t[0].indexOf(item)
    table_mixed.row.add([total[index][0], total[index][3], round(total[index][2], 2), round(total[index][1], 2)]).draw(false)
    del = dup.indexOf(item);
    dup.splice(del, 1);
  }
  }
  sessionStorage.setItem("mixedDuplicate", JSON.stringify(dup))
  // update html
  $("#showMixed").html(0)
  $("#allMixed").html(0)
  sessionStorage.setItem("mixedCatCurr", JSON.stringify([]));
  sessionStorage.setItem("mixedCatNot", JSON.stringify([]));
}

// remove one entry for category data
function minusMixed() {
  curr_cat = JSON.parse(sessionStorage.mixedCatCurr)
  if (curr_cat.length > 0) { 
  curr_not = JSON.parse(sessionStorage.mixedCatNot)

  item = curr_cat[curr_cat.length-1][0]
  curr = JSON.parse(sessionStorage.currMixed)
  curr_data = JSON.parse(sessionStorage.currData)
  index = curr.indexOf(item)

  // update bar chart by removing the lowest ranked 
  myMixedChart.data.datasets[0].data.splice(index, 1)
  myMixedChart.data.datasets[1].data.splice(index, 1)
  myMixedChart.data.datasets[2].data.splice(index, 1)
  myMixedChart.data.labels.splice(index, 1)
  myMixedChart.update()

  curr_not.splice(0, 0, curr_cat[curr_cat.length-1]) // add to non-displaying category data
  curr.splice(index, 1) // remove from current labels
  curr_data.splice(index, 1)
  curr_cat.splice(curr_cat.length-1, 1) // remove from current category data

  sessionStorage.setItem("mixedCatCurr", JSON.stringify(curr_cat));
  sessionStorage.setItem("mixedCatNot", JSON.stringify(curr_not));
  sessionStorage.setItem("currMixed", JSON.stringify(curr));
  sessionStorage.setItem("currData", JSON.stringify(curr_data));

  show = parseInt($("#showMixed").html()) - 1
  $("#showMixed").html(show)
}
}

// add an entry from category data
function addMixed() {
  curr_not = JSON.parse(sessionStorage.mixedCatNot)
  if (curr_not.length > 0) { 

  curr_cat = JSON.parse(sessionStorage.mixedCatCurr)
  item = curr_not[0][0]
  index = findInsertIndexMixed(curr_not[0])

  myMixedChart.data.datasets[0].data.splice(index, 0, curr_not[0][3])
  myMixedChart.data.datasets[1].data.splice(index, 0, curr_not[0][2])
  myMixedChart.data.datasets[2].data.splice(index, 0, curr_not[0][1])
  myMixedChart.data.labels.splice(index, 0, curr_not[0][0])

  myMixedChart.update()

  curr_cat = curr_cat.concat([curr_not[0]])
  curr_not.splice(0, 1)

  sessionStorage.setItem("mixedCatCurr", JSON.stringify(curr_cat));
  sessionStorage.setItem("mixedCatNot", JSON.stringify(curr_not));

  show = parseInt($("#showMixed").html()) + 1
  $("#showMixed").html(show)
}
}

// clear the whole canvas
function clearCanvasMixed() {
  current = JSON.parse(sessionStorage.mixedCurrent)
  for (t = 0; t < current.length; t++) {
    remove_item_mixed(" " + current[t])
  }
  remove_cat_mixed();
  table_mixed.clear();

  sessionStorage.setItem("currentMixedCat", "") // current investigated category
  sessionStorage.setItem("mixedSearch", JSON.stringify([])); // previous searches
  sessionStorage.setItem("mixedCurrent", JSON.stringify([])); // all the individual items added
  sessionStorage.setItem("mixedCatCurr", JSON.stringify([]));
  sessionStorage.setItem("mixedCatNot", JSON.stringify([]));

  sessionStorage.setItem("currMixed", JSON.stringify([])); // current labels stored in chart
  sessionStorage.setItem("currData", JSON.stringify([])); // current data associated with the chart
  sessionStorage.setItem("mixedDuplicate", JSON.stringify([])); // store duplicate entries between individual items and category
}

// change the year of all shown items to the given year; and change the associate order
function changeYearMixed() {
  // store the important data
  updateYearCat = sessionStorage.currentMixedCat
  console.log(updateYearCat)
  updateYearItems = JSON.parse(sessionStorage.mixedCurrent)
  console.log(updateYearItems)
  // clear the canvas
  clearCanvasMixed();

  for (u = 0; u < updateYearItems.length; u++) {
    addItemDataMixed(updateYearItems[u]);
  }

  if (updateYearCat != '') {
    addCatDataMixed(updateYearCat);
  }
}

</script>

<div style = "float: left; width: 100%">
<h1>Time Series of Real vs non-real food</h1>

<div>

<div class="quantity buttons_added">
  Showing
  <input type="button" value="-" class="minus" onclick = "minusTime()">
  <div id = "showTime" style = "display: inline">0</div>
  <input type="button" value="+" class="plus" onclick = "addTime()">
  out of <div id = "allTime" style = "display: inline">0</div> of the selected category

</div>

<div>
    <label for="add">Add by item:</label>
    <input id="add_time" type="text" name="text" list = "items_time" onkeyup = "searchItem()" autocomplete="off">
    <datalist id="items_time"></datalist>
    <input id = "submit_item_time" type="submit" value="submit" onclick = "addItemData()">
AND/OR Select a category: 
<select id = "categoriesTime">
  <option disabled selected value> select an option </option>
</select>
<input id = "submit_cat_time" type="submit" value="submit" onclick = "addCatData()">
</div>

<div>
  Remove:
<button class="btnic" id = "canvas_time" onclick = "clearCanvasTime()"><i class="fa fa-close"></i> Remove all canvas</button>
<button class="btnic" id = "remove_cat_time" onclick = "remove_cat_time()"><i class="fa fa-close"></i> Remove selected category</button>
<div style = "display:inline" id = "buttons_time"></div>
</div>
</div>

<div class="row">
  <div class="column" style = "width: 60%; height: 30%;  float: left">
    <canvas id="timeSeriesChart" style="display: block; width: 60%; height: 700px"></canvas>
  </div>
  <div class="column" style = "width: 40%; height: 30%; display: inline-block;">
    <table id="time_table" class="display" style = "display: inline-block;">
    <thead>
      <tr>
        <th>Item</th>
        <th>Type</th>
        <th>Year 1</th>
        <th>Year 2</th>
        <th>Year 3</th>
      </tr>
    </thead>
    <tbody>
    </tbody>
</table>
    </div>
</div>

</div>


<script>
// takes into two lists, and removes all elements in first list from the second list
function removeElements(e, l) {
  for (i = 0; i < e.length; i++) {
    index = l.indexOf(e[i])
    l.splice(index, 1)
  }
  return l
}
// Hash any string into an integer value
// Then we'll use the int and convert to hex.
function hashCode(str) {
    var hash = 0;
    for (var i = 0; i < str.length; i++) {
        hash = str.charCodeAt(i) + ((hash << 5) - hash);
    }
    return hash;
}

// Convert an int to hexadecimal with a max length
// of six characters.
function intToARGB(i) {
    var hex = ((i>>24)&0xFF).toString(16) +
            ((i>>16)&0xFF).toString(16) +
            ((i>>8)&0xFF).toString(16) +
            (i&0xFF).toString(16);
    // Sometimes the string returned will be too short so we
    // add zeros to pad it out, which later get removed if
    // the length is greater than six.
    hex += '000000';
    return hex.substring(0, 6);
}

function arraysEqual(arr1, arr2) {
    if(arr1.length !== arr2.length)
        return false;
    for(var i = arr1.length; i--;) {
        if(arr1[i] !== arr2[i])
            return false;
    }

    return true;
}

var searches_time = []; // current searches at every turn

c = $.get("http://cmc307-06.mathcs.carleton.edu:5001/visualization/get_categories/");

c.done(function(results) {
  cats = results.cats;
  for (i = 0; i < cats.length; i++) {
    cat = cats[i]
    $("select#categoriesTime").append( $("<option>")
    .val(cat)
    .html(cat)
);
  }
});

sessionStorage.setItem("currentTimeCat", "") // current investigated category
sessionStorage.setItem("timeSearch", JSON.stringify([])); // previous searches
sessionStorage.setItem("timeCurrent", JSON.stringify([])); // current items added
sessionStorage.setItem("timeConfigs", JSON.stringify([])); // different configurations for the chart
sessionStorage.setItem("timeChartLabels", JSON.stringify([])); // labels

sessionStorage.setItem("timeCurrCat", JSON.stringify([]));
sessionStorage.setItem("timeNotCat", JSON.stringify([]));

sessionStorage.setItem("timeDuplicate", JSON.stringify([]));

function searchItem() {
  x = document.getElementById("add_time").value;
  if (x.length > 1) {
  searches = $.get("http://cmc307-06.mathcs.carleton.edu:5001/visualization/get_item/" + x);

  old_searches = JSON.parse(sessionStorage.timeSearch);

    searches.done(function(results) {
    if (!arraysEqual(old_searches, results.search)) {
    sessionStorage.setItem("timeSearch", JSON.stringify(results.search));
      var dataList = $("#items_time");
        dataList.empty();
        if(results.search.length) {
          for(i=0; i<results.search.length; i++) {
            item = results.search[i];
            var opt = $("<option></option>").attr("value", item).attr("text", item);
            dataList.append(opt);
          }
        }
    }});
}
};
var total_configs = JSON.parse(sessionStorage.timeConfigs)

Chart.defaults.global.plugins.datalabels.display = false;

updatedTimeColumn = true;


 types = ['total', 'real']
 dashes = [[0, 0], [10, 5]]
var ctx5 = document.getElementById("timeSeriesChart").getContext('2d');
var myLineChart;

 lineChartData = {}
 lineChartData.datasets = []
// add legend for real vs non real
for (i = 0; i < types.length; i++) {
    line = {}
    line.data = 0 // arbitrary
    line.type = 'line'
    line.label = types[i]
    //line.backgroundColor = colors[i]
    if (i > 0) {
        line.borderDash = [10, 5]
    }
    line.fill = false
    line.showLine = false
    lineChartData.datasets.push(line)
}

ctx5 = document.getElementById("timeSeriesChart").getContext('2d');
myLineChart = new Chart(ctx5, {data: lineChartData,
    type: 'line',
    options: {scales: {yAxes:[{scaleLabel: {display: true, labelString: "Dollar purchases ($)"}, ticks: {min: 0}}]},
              legend: {
                display: true,
                fill: false,
                labels: {
                  filter: function(legendItem, data) {
                  //return legendItem.datasetIndex >= total_configs.length
                  return !total_configs.includes(data.datasets[legendItem.datasetIndex].label)
                }
              }
              },
              responsive: true,
              maintainAspectRatio: false
  }
});

var table;
$(document).ready(function(){table = $('#time_table').DataTable({
        dom: 'lBfrtip',
        buttons: ['copyHtml5', 'csvHtml5', 'excelHtml5']
    }); });

// add single item to the time series chart
function addItemData() {
  current_list = JSON.parse(sessionStorage.timeCurrent);
  y = document.getElementById("add_time").value.trim();
  // check input is longer than 1 and has not appeared in current list
  if (y.length > 1 && !current_list.includes(y)) {
    searches = $.get("http://cmc307-06.mathcs.carleton.edu:5001/visualization/item_data/" + y);

    searches.done(function(results) {
      types = ['total', 'real']
      myLineChart.data.labels = results.yrs

      if (updatedTimeColumn) {
        updatedTimeColumn = false;
        var head_item = table.columns(2).header();
        $(head_item).html(results.yrs[0]);

        var head_item = table.columns(3).header();
        $(head_item).html(results.yrs[1]);

        var head_item = table.columns(4).header();
        $(head_item).html(results.yrs[2]);
      }
      color = "#" + intToARGB(hashCode(y))

      cost = results.cost

  chart_labels = JSON.parse(sessionStorage.timeChartLabels);
  total_configs = JSON.parse(sessionStorage.timeConfigs)

  // add duplicate entries into the list
  var dup = JSON.parse(sessionStorage.timeDuplicate)
  curr = JSON.parse(sessionStorage.timeCurrCat)
  n = JSON.parse(sessionStorage.timeNotCat)

  if (curr.includes(y) || n.includes(y)) {
    dup.push(y)
  }
  sessionStorage.setItem("timeDuplicate", JSON.stringify(dup));
  


    for (j = 0; j < types.length; j++) {
        line = {}
        line.data = cost[j]
        line.type = 'line'
        line.label = types[j] + " " + y
        total_configs.push(line.label)
        chart_labels.push(line.label)
        //line.backgroundColor = colors[i]
        line.borderColor = color
        line.fill = false
        if (j > 0) {
            line.borderDash = [10, 5]
        }
        myLineChart.data.datasets.push(line)
        table.row.add([y, types[j], cost[j][0], cost[j][1], cost[j][2]]).draw(false)
    }
// add legend for each item
    line = {}
    line.data = 0 // arbitrary
    line.type = 'line'
    line.label = y
    chart_labels.push(line.label)
    line.backgroundColor = color
    line.borderColor = color
    line.fill = true
    line.showLine = false
    myLineChart.data.datasets.push(line)

  myLineChart.update();

sessionStorage.setItem("timeConfigs", JSON.stringify(total_configs));
sessionStorage.setItem("timeChartLabels", JSON.stringify(chart_labels)); // labels

// add option to remove
$('#buttons_time').append('<button class="btnic" id = "time_' + y + '" onclick = "remove_item_time(&quot ' + y + '&quot)"><i class="fa fa-close"></i> ' + y + '</button>');

    })

    sessionStorage.setItem("timeCurrent", JSON.stringify(current_list.concat([y])));
  }
}

function addCatData() {
  cat = $("select#categoriesTime").val();
  if (sessionStorage.currentTimeCat != "" && sessionStorage.currentTimeCat != cat) {
      remove_cat_time();
    }
  if (sessionStorage.currentTimeCat != cat) {
  curr = []
  not = []
  searches = $.get("http://cmc307-06.mathcs.carleton.edu:5001/visualization/get_categories_time/" + cat);
  searches.done(function(results) {
    num_items = Math.min(results.items.length, 3)

  show = parseInt($("#showTime").html()) + num_items
  all = parseInt($("#allTime").html()) + results.items.length
  $("#showTime").html(show)
  $("#allTime").html(all)

    cost = results.cost
    items = results.items
    types = ['total', 'real']
    myLineChart.data.labels = results.yrs

    // update column years
          if (updatedTimeColumn) {
        updatedTimeColumn = false;
        var head_item = table.columns(2).header();
        $(head_item).html(results.yrs[0]);

        var head_item = table.columns(3).header();
        $(head_item).html(results.yrs[1]);

        var head_item = table.columns(4).header();
        $(head_item).html(results.yrs[2]);
      }

    chart_labels = JSON.parse(sessionStorage.timeChartLabels);
    total_configs = JSON.parse(sessionStorage.timeConfigs)

    colors = []

    for (i = 0; i < num_items; i++) {
      curr.push(items[i])
    for (j = 0; j < types.length; j++) {
        line = {}
        line.data = cost[j][i]
        line.type = 'line'
        line.label = types[j] + " " + items[i]

        total_configs.push(line.label)
        chart_labels.push(line.label)
        //line.backgroundColor = colors[i]
        color = "#" + intToARGB(hashCode(items[i]))
        colors.push(color)
        line.borderColor = color
        line.fill = false
        if (j > 0) {
            line.borderDash = [10, 5]
        }
        myLineChart.data.datasets.push(line)
    }
    // legend line
    line = {}
    line.data = 0 // arbitrary
    line.type = 'line'
    line.label = items[i]
    line.backgroundColor = color
    line.borderColor = color
    //line.fillColor = colors[i]
    line.fill = true
    line.showLine = false
    chart_labels.push(line.label)
    myLineChart.data.datasets.push(line)
  }

  // add duplicate entries into the list
  var dup = JSON.parse(sessionStorage.timeDuplicate)

curr_ind = JSON.parse(sessionStorage.timeCurrent)
  // add data to table
  for (i = 0; i < items.length; i++) {
    if (curr_ind.includes(items[i])) {
      dup.push(items[i])
    }
    for (j = 0; j < types.length; j++) {
      table.row.add([items[i], types[j], cost[j][i][0], cost[j][i][1], cost[j][i][2]]).draw(false)
    }
  }

  sessionStorage.setItem("timeDuplicate", JSON.stringify(dup))

  sessionStorage.setItem("timeConfigs", JSON.stringify(dup));

  for (k = num_items; k < items.length; k++) {
    not.push(items[k])
  }


  myLineChart.update();
  sessionStorage.setItem("timeConfigs", JSON.stringify(total_configs));
   sessionStorage.setItem("timeChartLabels", JSON.stringify(chart_labels));

  sessionStorage.setItem("timeCurrCat", JSON.stringify(curr));
  sessionStorage.setItem("timeNotCat", JSON.stringify(not));
  sessionStorage.setItem("timeCatCost", JSON.stringify(cost));


  })
  sessionStorage.setItem("currentTimeCat", cat);
}
};

function remove_item_time(item) {
  types = ['total', 'real']
  item = item.substring(1)

  timeChartLabels = JSON.parse(sessionStorage.timeChartLabels)

  // remove legend data
  index = timeChartLabels.indexOf(item) + 2
  myLineChart.data.datasets.splice(index, 1);
  timeChartLabels = removeElements([item], timeChartLabels)

  // remove real data
  index = timeChartLabels.indexOf("real " + item) + 2
  myLineChart.data.datasets.splice(index, 1);
  timeChartLabels = removeElements(["real " + item], timeChartLabels)

  // remove total data in chart
  index = timeChartLabels.indexOf("total " + item) + 2
  myLineChart.data.datasets.splice(index, 1);
  timeChartLabels = removeElements(["total " + item], timeChartLabels)

  total_configs = removeElements(["real " + item, "total " + item], JSON.parse(sessionStorage.timeConfigs))

  myLineChart.update();

  // load duplicate list
  var dup = JSON.parse(sessionStorage.timeDuplicate)

  sessionStorage.setItem("timeCurrent", JSON.stringify(removeElements([item], JSON.parse(sessionStorage.timeCurrent))));
  sessionStorage.setItem("timeConfigs", JSON.stringify(total_configs));
  sessionStorage.setItem("timeChartLabels", JSON.stringify(timeChartLabels));

  //item_id = "#time_" + item
  item_id = "[id='time_" + item + "']"
  console.log(item_id)
  $(item_id).remove()

  table.rows( function ( idx, data, node ) {
        return data[0] === item;
    } )
    .remove()
    .draw();

  if (dup.includes(item)) {
    curr = JSON.parse(sessionStorage.timeCurrCat)
    n = JSON.parse(sessionStorage.timeNotCat)

    if (curr.includes(item)) {
      index = curr.indexOf(item)
    }
    if (n.includes(item)) {
      index = curr.length + n.indexOf(item)
    }
    console.log(dup)
    console.log(item)
    cost = JSON.parse(sessionStorage.timeCatCost)
    for (j = 0; j < types.length; j++) {
      table.row.add([item, types[j], cost[j][index][0], cost[j][index][1], cost[j][index][2]]).draw(false)
    }

    var del = dup.indexOf(item);
    dup.splice(del, 1);
  }
  sessionStorage.setItem("timeDuplicate", JSON.stringify(dup))

}

function remove_cat_time() {
  types = ['total', 'real']
  // load duplicate list
  dup = JSON.parse(sessionStorage.timeDuplicate)
  cost = JSON.parse(sessionStorage.timeCatCost)

  timeChartLabels = JSON.parse(sessionStorage.timeChartLabels)
  curr = JSON.parse(sessionStorage.timeCurrCat)
  for (p = 0; p < curr.length; p++) {
    item = curr[p]
// remove legend data
  index = timeChartLabels.indexOf(item) + 2
  myLineChart.data.datasets.splice(index, 1);
  timeChartLabels = removeElements([item], timeChartLabels)

  // remove real data
  index = timeChartLabels.indexOf("real " + item) + 2
  myLineChart.data.datasets.splice(index, 1);
  timeChartLabels = removeElements(["real " + item], timeChartLabels)

  // remove total data in chart
  index = timeChartLabels.indexOf("total " + item) + 2
  myLineChart.data.datasets.splice(index, 1);
  timeChartLabels = removeElements(["total " + item], timeChartLabels)

  total_configs = removeElements(["real " + item, "total " + item], JSON.parse(sessionStorage.timeConfigs))
  sessionStorage.setItem("timeConfigs", JSON.stringify(total_configs));

  }

  myLineChart.update();
  total = curr.concat(JSON.parse(sessionStorage.timeNotCat))
  for (z = 0; z < total.length; z++) {
    table.rows( function ( idx, data, node ) {
        return data[0] === total[z];
    } )
    .remove()
    .draw();
    item = total[z]

  if (dup.includes(item)) {
    console.log(dup)
    console.log(item)
    console.log(total)
    index = total.indexOf(item)
    for (j = 0; j < types.length; j++) {
      table.row.add([item, types[j], cost[j][index][0], cost[j][index][1], cost[j][index][2]]).draw(false)
    }
    var del = dup.indexOf(item);
    dup.splice(del, 1);
  }

  }
    sessionStorage.setItem("timeDuplicate", JSON.stringify(dup))

  // add duplicated entries between category and item entry back into the table

  sessionStorage.setItem("timeCurrCat", JSON.stringify([]));
  sessionStorage.setItem("timeNotCat", JSON.stringify([]));

  sessionStorage.setItem("timeChartLabels", JSON.stringify(timeChartLabels));
  sessionStorage.setItem("currentTimeCat", "");

  $("#showTime").html(0)
  $("#allTime").html(0)

}

function minusTime() {
  if (sessionStorage.currentTimeCat == "") {return;}
  check = JSON.parse(sessionStorage.timeCurrCat)
  if (check.length > 0) {
  $("#showTime").html(parseInt($("#showTime").html()) - 1)
  timeChartLabels = JSON.parse(sessionStorage.timeChartLabels)
  total_configs = JSON.parse(sessionStorage.timeConfigs)
  item = check[check.length - 1]

  index = timeChartLabels.indexOf(item) + 2
  myLineChart.data.datasets.splice(index, 1);
  timeChartLabels = removeElements([item], timeChartLabels)

  // remove real data
  index = timeChartLabels.indexOf("real " + item) + 2
  myLineChart.data.datasets.splice(index, 1);
  timeChartLabels = removeElements(["real " + item], timeChartLabels)

  // remove total data in chart
  index = timeChartLabels.indexOf("total " + item) + 2
  myLineChart.data.datasets.splice(index, 1);
  timeChartLabels = removeElements(["total " + item], timeChartLabels)

  total_configs = removeElements(["real " + item, "total " + item], total_configs)
  myLineChart.update();

  console.log(total_configs)
  console.log(timeChartLabels)

  sessionStorage.setItem("timeConfigs", JSON.stringify(total_configs));
  sessionStorage.setItem("timeChartLabels", JSON.stringify(timeChartLabels));

  check.splice(check.length-1, 1)
  sessionStorage.setItem("timeCurrCat", JSON.stringify(check));
  sessionStorage.setItem("timeNotCat", JSON.stringify([item].concat(JSON.parse(sessionStorage.timeNotCat))));

}
}

function addTime() {
  if (sessionStorage.currentTimeCat == "") {return;}
  check = JSON.parse(sessionStorage.timeNotCat)
  if (check.length > 0) {
    $("#showTime").html(parseInt($("#showTime").html()) + 1)
    y = check[0]
    chart_labels = JSON.parse(sessionStorage.timeChartLabels);
    total_configs = JSON.parse(sessionStorage.timeConfigs)
    costs = JSON.parse(sessionStorage.timeCatCost)
    past = JSON.parse(sessionStorage.timeCurrCat)


    color = "#" + intToARGB(hashCode(y))
    for (j = 0; j < types.length; j++) {
        line = {}
        line.data = costs[j][past.length]
        line.type = 'line'
        line.label = types[j] + " " + y
        total_configs.push(line.label)
        chart_labels.push(line.label)
        //line.backgroundColor = colors[i]
        line.borderColor = color
        line.fill = false
        if (j > 0) {
            line.borderDash = [10, 5]
        }
        myLineChart.data.datasets.push(line)
    }
// console.log(datasets.toString())
// add legend for each item
    line = {}
    line.data = 0 // arbitrary
    line.type = 'line'
    line.label = y
    chart_labels.push(line.label)
    line.backgroundColor = color
    line.borderColor = color
    //line.fillColor = colors[i]
    line.fill = true
    line.showLine = false
    myLineChart.data.datasets.push(line)

  myLineChart.update();
  console.log(total_configs)
  console.log(chart_labels)
  sessionStorage.setItem("timeConfigs", JSON.stringify(total_configs));
  sessionStorage.setItem("timeChartLabels", JSON.stringify(chart_labels));

  check.splice(0, 1)
  sessionStorage.setItem("timeCurrCat", JSON.stringify(past.concat([y])));
  sessionStorage.setItem("timeNotCat", JSON.stringify(check));
  }
}

function clearCanvasTime() {
current = JSON.parse(sessionStorage.timeCurrent)
for (t = 0; t < current.length; t++) {
  remove_item_time(" " + current[t])
}
remove_cat_time();
table.clear();

sessionStorage.setItem("currentTimeCat", "") // current investigated category
sessionStorage.setItem("timeSearch", JSON.stringify([])); // previous searches
sessionStorage.setItem("timeCurrent", JSON.stringify([])); // current items added
sessionStorage.setItem("timeConfigs", JSON.stringify([])); // different configurations for the chart
sessionStorage.setItem("timeChartLabels", JSON.stringify([])); // labels

sessionStorage.setItem("timeCurrCat", JSON.stringify([]));
sessionStorage.setItem("timeNotCat", JSON.stringify([]));
sessionStorage.setItem("timeDuplicate", JSON.stringify([]));

}
</script>


<div style = "float:left; width: 100%">
  <h1>Item, Vendor and Label</h1>

    <label for="add">Search By item:</label>
    <input id="item_liv" type="text" name="text" list = "items_list" onkeyup = "searchLivItem()" autocomplete="off">
    <datalist id="items_list"></datalist>
    <input id = "submit_item_liv" type="submit" value="submit" onclick = "addLivItem()">

OR 

    <label for="add">By vendor:</label>
    <input id="vendor_liv" type="text" name="text" list = "vendor_list" onkeyup = "searchLivVendor()" autocomplete="off">
    <datalist id="vendor_list"></datalist>
    <input id = "submit_vendor_liv" type="submit" value="submit" onclick = "addLivVendor()">

OR 

    <label for="add">By label/brand:</label>
    <input id="label_liv" type="text" name="text" list = "label_list" onkeyup = "searchLivLabel()" autocomplete="off">
    <datalist id="label_list"></datalist>
    <input id = "submit_label_liv" type="submit" value="submit" onclick = "addLivLabel()">

</div>

<div class="row">
  <div class="column" style = "width: 50%; height: 25%;  float: left">

    <div class="quantity buttons_added">
    Showing
    <input type="button" value="-" class="minus" onclick = "minusLiv1()">
    <div id = "showLiv1" style = "display: inline">0</div>
    <input type="button" value="+" class="plus" onclick = "addLiv1()">
    out of <div id = "allLiv1" style = "display: inline">0</div> of the selected category
    </div>

    <canvas id="livChart1" style="display: block; height: 60px; width: 50%;"></canvas>
    <canvas id="livChart2" style="display: block; height: 60px; width: 50%;"></canvas>
    <table id="liv_table1" class="display" style = "display: inline-block;">
    <thead>
      <tr>
        <th>Item</th>
        <th>Year 1</th>
        <th>Year 2</th>
        <th>Year 3</th>
        <th>All 3 years</th>
      </tr>
    </thead>
    <tbody>
    </tbody>
</table>
  </div>

  <div class="column" style = "width: 50%; height: 25%;  float: left">

    <div class="quantity buttons_added">
    Showing
    <input type="button" value="-" class="minus" onclick = "minusLiv2()">
    <div id = "showLiv2" style = "display: inline">0</div>
    <input type="button" value="+" class="plus" onclick = "addLiv2()">
    out of <div id = "allLiv2" style = "display: inline">0</div> of the selected category

    </div>

    <canvas id="livChart3" style="display: block; height: 60px; width: 50%;"></canvas>
    <canvas id="livChart4" style="display: block; height: 60px; width: 50%;"></canvas>
        <table id="liv_table2" class="display" style = "display: inline-block;">
    <thead>
      <tr>
        <th>Item</th>
        <th>Year 1</th>
        <th>Year 2</th>
        <th>Year 3</th>
        <th>All 3 years</th>
      </tr>
    </thead>
    <tbody>
    </tbody>
</table>
  </div>

</div>



<script>
  // create new chart type for stacked grouped bar chart
Chart.defaults.groupableBar = Chart.helpers.clone(Chart.defaults.bar);

var helpers = Chart.helpers;
Chart.controllers.groupableBar = Chart.controllers.bar.extend({
  calculateBarX: function (index, datasetIndex) {
    // position the bars based on the stack index
    var stackIndex = this.getMeta().stackIndex;
    return Chart.controllers.bar.prototype.calculateBarX.apply(this, [index, stackIndex]);
  },

  hideOtherStacks: function (datasetIndex) {
    var meta = this.getMeta();
    var stackIndex = meta.stackIndex;

    this.hiddens = [];
    for (var i = 0; i < datasetIndex; i++) {
      var dsMeta = this.chart.getDatasetMeta(i);
      if (dsMeta.stackIndex !== stackIndex) {
        this.hiddens.push(dsMeta.hidden);
        dsMeta.hidden = true;
      }
    }
  },

  unhideOtherStacks: function (datasetIndex) {
    var meta = this.getMeta();
    var stackIndex = meta.stackIndex;

    for (var i = 0; i < datasetIndex; i++) {
      var dsMeta = this.chart.getDatasetMeta(i);
      if (dsMeta.stackIndex !== stackIndex) {
        dsMeta.hidden = this.hiddens.unshift();
      }
    }
  },

  calculateBarY: function (index, datasetIndex) {
    this.hideOtherStacks(datasetIndex);
    var barY = Chart.controllers.bar.prototype.calculateBarY.apply(this, [index, datasetIndex]);
    this.unhideOtherStacks(datasetIndex);
    return barY;
  },

  calculateBarBase: function (datasetIndex, index) {
    this.hideOtherStacks(datasetIndex);
    var barBase = Chart.controllers.bar.prototype.calculateBarBase.apply(this, [datasetIndex, index]);
    this.unhideOtherStacks(datasetIndex);
    return barBase;
  },

  getBarCount: function () {
    var stacks = [];

    // put the stack index in the dataset meta
    Chart.helpers.each(this.chart.data.datasets, function (dataset, datasetIndex) {
      var meta = this.chart.getDatasetMeta(datasetIndex);
      if (meta.bar && this.chart.isDatasetVisible(datasetIndex)) {
        var stackIndex = stacks.indexOf(dataset.stack);
        if (stackIndex === -1) {
          stackIndex = stacks.length;
          stacks.push(dataset.stack);
        }
        meta.stackIndex = stackIndex;
      }
    }, this);

    this.getMeta().stacks = stacks;
    return stacks.length;
  },
});

sessionStorage.setItem("itemsLivSearch", JSON.stringify([]));
sessionStorage.setItem("vendorSearch", JSON.stringify([]));
sessionStorage.setItem("labelSearch", JSON.stringify([]));

var ctx10 = document.getElementById("livChart1").getContext('2d');
var ctx11 = document.getElementById("livChart2").getContext('2d');
var ctx12 = document.getElementById("livChart3").getContext('2d');
var ctx13 = document.getElementById("livChart4").getContext('2d');

var ctx1x = [ctx10, ctx11, ctx12, ctx13]

var myLivChart1 = new Chart(ctx10, {type: 'bar', options: {scales: {yAxes: [{ticks: {min: 0}}]}}});
var myLivChart2 = new Chart(ctx11, {type: 'bar', options: {scales: {yAxes: [{ticks: {min: 0}}]}}});
var myLivChart3 = new Chart(ctx12, {type: 'bar', options: {scales: {yAxes: [{ticks: {min: 0}}]}}});
var myLivChart4 = new Chart(ctx13, {type: 'bar', options: {scales: {yAxes: [{ticks: {min: 0}}]}}});

var LivCharts = [myLivChart1, myLivChart2, myLivChart3, myLivChart4]

var yrs = [];

function searchLivItem() {
  x = document.getElementById("item_liv").value;
  if (x.length > 1) {
  searches = $.get("http://cmc307-06.mathcs.carleton.edu:5001/visualization/get_item/" + x);

  old_searches = JSON.parse(sessionStorage.itemsLivSearch);

    searches.done(function(results) {
    if (!arraysEqual(old_searches, results.search)) {
    sessionStorage.setItem("itemsLivSearch", JSON.stringify(results.search));
      var dataList = $("#items_list");
        dataList.empty();
        if(results.search.length) {
          for(i=0; i<results.search.length; i++) {
            item = results.search[i];
            var opt = $("<option></option>").attr("value", item).attr("text", item);
            dataList.append(opt);
          }
        }
    }});
}
}

function searchLivVendor() {
  x = document.getElementById("vendor_liv").value;
  if (x.length > 1) {
  searches = $.get("http://cmc307-06.mathcs.carleton.edu:5001/visualization/get_vendor/" + x);

  old_searches = JSON.parse(sessionStorage.vendorSearch);

    searches.done(function(results) {
    if (!arraysEqual(old_searches, results.search)) {
    sessionStorage.setItem("vendorSearch", JSON.stringify(results.search));
      var dataList = $("#vendor_list");
        dataList.empty();
        if(results.search.length) {
          for(i=0; i<results.search.length; i++) {
            item = results.search[i];
            var opt = $("<option></option>").attr("value", item).attr("text", item);
            dataList.append(opt);
          }
        }
    }});
}
}

function searchLivLabel() {
  x = document.getElementById("label_liv").value;
  if (x.length > 1) {
  searches = $.get("http://cmc307-06.mathcs.carleton.edu:5001/visualization/get_label/" + x);

  old_searches = JSON.parse(sessionStorage.labelSearch);

    searches.done(function(results) {
    if (!arraysEqual(old_searches, results.search)) {
    sessionStorage.setItem("labelSearch", JSON.stringify(results.search));
      var dataList = $("#label_list");
        dataList.empty();
        if(results.search.length) {
          for(i=0; i<results.search.length; i++) {
            item = results.search[i];
            var opt = $("<option></option>").attr("value", item).attr("text", item);
            dataList.append(opt);
          }
        }
    }});
}
}
var real_color = "rgba(99,132,255,"
var nonreal_color = "rgba(255,99,132,"
var year_offset = ["0.2)", "0.6)", "1.0)"]

function plotByYear(t, s, r, n, l, v, c) {
data = {}
data.labels = l
datasets = []

for (i = 0; i < year_offset.length; i++) {
  bar = {}
  bar.label = "real"
  bar.backgroundColor = real_color + year_offset[i]
  bar.borderColor = real_color + year_offset[i]
  bar.data = r[i]
  bar.stack = i+1

  bar2 = {}
  bar2.label = "nonreal"
  bar2.backgroundColor = nonreal_color + year_offset[i]
  bar2.borderColor = nonreal_color + year_offset[i]
  bar2.data = n[i]
  bar2.stack = i+1

  datasets.push(bar)
  datasets.push(bar2)

}

data.datasets = datasets

var d = datasets
LivCharts[v] = new Chart(ctx1x[c], {
  type: 'groupableBar',
  data: data,
  options: {
    plugins: {
            datalabels: {
              anchor: 'end',
              clamp: true,
              display: function(context) {
                if (context.datasetIndex % 2) {
                non_real_data = d[context.datasetIndex - 1].data[context.dataIndex]
                // console.log(non_real_data)
                // console.log((context.datasetIndex % 2) && (context.dataset.data[context.dataIndex] > 0 || non_real_data > 0))
              }
              else {
                non_real_data = -1
            }
              return (context.datasetIndex % 2) && (context.dataset.data[context.dataIndex] > 0 || non_real_data > 0); // display labels with an odd index
                },
                formatter: function(value, context) {
                    return yrs[(context.datasetIndex-1)/2];
                }
            }
        },

    legend: {
      labels: {
        generateLabels: function(chart) {
          return Chart.defaults.global.legend.labels.generateLabels.apply(this, [chart]).filter(function(item, i){
              return i <= 1;
          });
        }
      }
    },
    scales: {
      yAxes: [{
        ticks: {
          min: 0
        },
        stacked: true,
      }],
      xAxes: [{
        ticks: {
          autoSkip: false
        }
      }]
    },
            title: {
              display: true,
              text: "Distribution of " + t + " for " + s + " by 3 most recent years"
          }
  }
})
};

function plotByAll(t, s, r, n, l, v, c) {
   data = {
      datasets: [{
          label: "real",
          data: r,
          borderWidth: 2,
          backgroundColor: real_color + year_offset[2],
          borderColor: real_color + year_offset[2]
      },
      {
          label: "non-real",
          data: n,
          borderWidth: 2,
          backgroundColor: nonreal_color + year_offset[2],
          borderColor: nonreal_color + year_offset[2]
        }
      ],
      // These labels appear in the legend and in the tooltips when hovering different arcs
      labels: l,
      options: {
          responsive: true
      }
  };

  LivCharts[v] = new Chart(ctx1x[c], {
      type: 'bar',
      data: data,
      options: {
          scales: {
              xAxes: [{
                  stacked: true,
                  ticks: {
                    autoSkip: false
                  }
              }],
              yAxes: [{
                  stacked: true,
                  ticks: {
                    min: 0
                  }
              }]},
              title: {
              display: true,
              text: "Distribution of " + t + " for " + s + " for all time"
          }

      }
    })
}
// below functions read in user submitted data and re-draw all the plots
function addLivItem() {
  LivCharts[0].destroy();
  LivCharts[1].destroy();
  LivCharts[2].destroy();
  LivCharts[3].destroy();

  y = document.getElementById("item_liv").value.trim();

  searches = $.get("http://cmc307-06.mathcs.carleton.edu:5001/visualization/brand_vendor_data/" + y + "+item");

  searches.done(function(results) {
    label_brand = results.label_brand
    vendor = results.vendor
    yrs = results.yrs

    data_label_year = {}
    data_label_all = {}
    data_vendor_year = {}
    data_vendor_all = {}

    data_label_year.labels = label_brand
    data_label_all.labels = label_brand
    data_vendor_year.labels = vendor
    data_vendor_all.labels = vendor


    datasets1 = {}
    datasets2 = {}


    dr = results['label_brand real']
    dn = results['label_brand nonreal']

    dr = dr[0].map((col, i) => dr.map(row => row[i]));
    dn = dn[0].map((col, i) => dn.map(row => row[i]));

    l_label = results['label_brand']
    l_vendor = results['vendor']

    // replace empty string with NA
    for (i = 0; i < l_label.length; i++) {
      if (l_label[i] == "") {
        l_label[i] = "NA"
      }
    }

    for (i = 0; i < l_vendor.length; i++) {
      if (l_vendor[i] == "") {
        l_vendor[i] = "NA"
      }
    }

    plotByYear("label/brand", y, dr.slice(0, 3), dn.slice(0,3), l_label, 0, 0);
    plotByAll("label/brand", y, dr[3], dn[3], l_label, 1, 1);

    vr = results['vendor real']
    vn = results['vendor nonreal']

    vr = vr[0].map((col, i) => vr.map(row => row[i]));
    vn = vn[0].map((col, i) => vn.map(row => row[i]));

    plotByYear("vendor", y, vr.slice(0, 3), vn.slice(0,3), l_vendor, 2, 2);
    plotByAll("vendor", y, vr[3], vn[3], l_vendor, 3, 3);

  })
}

function addLivVendor() {
  LivCharts[0].destroy();
  LivCharts[1].destroy();
  LivCharts[2].destroy();
  LivCharts[3].destroy();

  y = document.getElementById("vendor_liv").value.trim();

  searches = $.get("http://cmc307-06.mathcs.carleton.edu:5001/visualization/brand_vendor_data/" + y + "+vendor");

  searches.done(function(results) {
    label_brand = results.label_brand
    description = results.description
    yrs = results.yrs

    dr = results['label_brand real']
    dn = results['label_brand nonreal']

    dr = dr[0].map((col, i) => dr.map(row => row[i]));
    dn = dn[0].map((col, i) => dn.map(row => row[i]));

    l_label = results['label_brand']
    l_items = results['description']

    // replace empty string with NA
    for (i = 0; i < l_label.length; i++) {
      if (l_label[i] == "") {
        l_label[i] = "NA"
      }
    }

    for (i = 0; i < l_items.length; i++) {
      if (l_items[i] == "") {
        l_items[i] = "NA"
      }
    }

    plotByYear("label/brand", y, dr.slice(0, 3), dn.slice(0,3), l_label, 0, 0);
    plotByAll("label/brand", y, dr[3], dn[3], l_label, 1, 1);

    vr = results['description real']
    vn = results['description nonreal']

    vr = vr[0].map((col, i) => vr.map(row => row[i]));
    vn = vn[0].map((col, i) => vn.map(row => row[i]));

    plotByYear("items", y, vr.slice(0, 3), vn.slice(0,3), l_items, 2, 2);
    plotByAll("items", y, vr[3], vn[3], l_items, 3, 3);
  })
}
  
// plot label charts on the canvas
function addLivLabel() {
  LivCharts[0].destroy();
  LivCharts[1].destroy();
  LivCharts[2].destroy();
  LivCharts[3].destroy();

  y = document.getElementById("label_liv").value.trim();

  searches = $.get("http://cmc307-06.mathcs.carleton.edu:5001/visualization/brand_vendor_data/" + y + "+brand");

  searches.done(function(results) {
    description = results.description
    vendor = results.vendor
    yrs = results.yrs


    dr = results['description real']
    dn = results['description nonreal']

    dr = dr[0].map((col, i) => dr.map(row => row[i]));
    dn = dn[0].map((col, i) => dn.map(row => row[i]));

    l_items = results['description']
    l_vendor = results['vendor']

    // replace empty string with NA
    for (i = 0; i < l_items.length; i++) {
      if (l_items[i] == "") {
        l_items[i] = "NA"
      }
    }

    for (i = 0; i < l_vendor.length; i++) {
      if (l_vendor[i] == "") {
        l_vendor[i] = "NA"
      }
    }

    plotByYear("items", y, dr.slice(0, 3), dn.slice(0,3), l_items, 0, 0);
    plotByAll("items", y, dr[3], dn[3], l_items, 1, 1);

    vr = results['vendor real']
    vn = results['vendor nonreal']

    vr = vr[0].map((col, i) => vr.map(row => row[i]));
    vn = vn[0].map((col, i) => vn.map(row => row[i]));

    plotByYear("vendor", y, vr.slice(0, 3), vn.slice(0,3), l_vendor, 2, 2);
    plotByAll("vendor", y, vr[3], vn[3], l_vendor, 3, 3);
  })
}
</script>

</body>


</html>
